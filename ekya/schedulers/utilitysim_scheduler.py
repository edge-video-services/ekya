import json
from typing import List

from ekya.classes.camera import Camera
from ekya.classes.model import DEFAULT_HYPERPARAMETERS
from ekya.schedulers.scheduler import BaseScheduler, fair_reallocation
from ekya.schedulers.utils import prepare_hyperparameters


class UtilitySimScheduler(BaseScheduler):
    def __init__(self,
                 schedule_path: str,
                 hyps_path: str,
                 schedule_key: str,
                 default_hyperparams: dict):
        '''
        Reads a schedule generated from utilitysim_v4 and corresponding hyperparameters and loads it into ekya.
        Requires ["task_id"] to be passed in the state for get_schedule.
        :param schedule_path: Path to the schedule (period allocation) generated by utilitysim
        :param hyps_path: hyp_map.json path which lists the hyperparameter_id to hyperparameter mapping
        :param schedule_key: The top level key in the schedule json. Usually of the format "{}_{}_{}_{}".format(period,res_count,scheduler,use_oracle)
        :param default_hyperparams: Default hyperparameter to use for inference if none found in training.
        '''
        self.schedule_path = schedule_path
        self.hyps_path = hyps_path
        self.schedule_key = schedule_key
        self.inference_default_hyperparam = default_hyperparams

    def get_schedule(self,
                     cameras: Camera,
                     resources: float,
                     state: dict) -> [dict, dict, dict]:
        with open(self.schedule_path) as f:
            schedule = json.load(f)
        with open(self.hyps_path) as f:
            hyperparams = json.load(f)

        task_id = str(state["task_id"])
        inference_resource_weights = {}
        training_resource_weights = {}
        hyperparameters = {}

        if task_id not in schedule[self.schedule_key]:
            raise KeyError("Task {} not found in schedule. Tasks available: {}".format(task_id, schedule[self.schedule_key].keys()))

        for job_id in schedule[self.schedule_key][task_id]['0']:
            cityname = job_id.split('_')[0]
            camera_id = cityname
            resource_alloc = schedule[self.schedule_key][task_id]['0'][job_id]
            #TODO(romilb): This needs to be more careful (eg. when > 1 resources are allocated)
            resource_alloc *= 100
            job_type = "train" if "train" in job_id else "inference"
            if job_type == "train":
                epochs = int(job_id.split('_')[-1])
                hp_id = job_id.split('_')[-2]
                this_hyps = hyperparams[hp_id]
                this_hyps['epochs'] = epochs
                this_hyps = prepare_hyperparameters(this_hyps)
                hyperparameters[camera_id] = this_hyps
                training_resource_weights[camera_id] = resource_alloc
            elif job_type == "inference":
                inference_resource_weights[camera_id] = resource_alloc
            else:
                raise NotImplementedError("Jobtype not identified while reading schedule file. {}".format(job_id))

            # Assign default hyperparameters
            for camera_id in inference_resource_weights:
                if camera_id not in hyperparameters:
                    print("UtilitySim: No hyperparameters found from training for camera {}. Using default hyperparams for inference.".format(camera_id))
                    hyperparameters[camera_id] = self.inference_default_hyperparam
        return inference_resource_weights, training_resource_weights, hyperparameters

    def get_inference_schedule(self,
                                cameras: List[Camera],
                                resources: float):
        '''
        Returns a fair schedule when inference only jobs must be run. This must be super fast since this is the schedule
        used before the get_schedule actual schedule is obtained.
        :param cameras: list of cameras
        :param resources: total resources in the system to be split across tasks
        :return: inference resource weights, hyperparameters
        '''
        inference_resource_weights = {c.id: (resources / (len(cameras))) * 100 for c in cameras}
        hyperparameters = {c.id: self.inference_default_hyperparam for c in cameras}
        return inference_resource_weights, hyperparameters

    def reallocation_callback(self,
                              completed_camera_name: str,
                              inference_resource_weights: dict,
                              training_resources_weights: dict) -> [dict, dict]:
        return fair_reallocation(completed_camera_name,
                          inference_resource_weights,
                          training_resources_weights)
